module IssuerTrigger where

-- import qualified DA.Next.Set as Set
-- import DA.Foldable hiding (elem, null)
-- import DA.Action
--
-- import Daml.Trigger
--
-- import Marketplace.Registry
-- import Marketplace.Token
--
-- import Utils
--
-- handleIssuer : Trigger ()
-- handleIssuer = Trigger
--   { initialize = return ()
--   , updateState = \_ -> pure ()
--   , rule = handleIssuerRule
--   , registeredTemplates = RegisteredTemplates  [ registeredTemplate @Token
--                                                , registeredTemplate @RegisteredBroker
--                                                , registeredTemplate @RegisteredCustodian
--                                                , registeredTemplate @RegisteredExchange
--                                                , registeredTemplate @RegisteredInvestor ]
--   , heartbeat = None
--   }
--
-- type ContractPair a = (ContractId a, a)
--
-- handleIssuerRule : Party -> TriggerA () ()
-- handleIssuerRule party = do
--   tokens     <- query @Token
--   brokers    <- map (broker . snd)    <$> query @RegisteredBroker
--   custodians <- map (custodian . snd) <$> query @RegisteredCustodian
--   exchanges  <- map (exchange . snd)  <$> query @RegisteredExchange
--   investors  <- map (investor . snd)  <$> query @RegisteredInvestor
--   let parties = brokers <> custodians <> exchanges <> investors
--   debug $ "tokens: " <> show tokens
--   debug $ "parties: " <> show parties
--   forA_ tokens (handleToken party parties)
--
-- -- |Add all parties as observers to a 'Token'
-- handleToken : Party -> [Party] -> ContractPair Token -> TriggerA () ()
-- handleToken party parties (cid,token) = do
--   let partiesToAdd = Set.difference (Set.fromList parties) token.observers
--   unless (Set.null partiesToAdd)
--     $ void $ emitCommand cid Token_AddObservers with party = party, newObservers = partiesToAdd
--     >> debug "adding parties to token..."
