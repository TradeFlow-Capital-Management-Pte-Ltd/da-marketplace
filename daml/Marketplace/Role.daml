daml 1.2
module Marketplace.Role where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types
import DA.List as L
import DA.Next.Set

import Marketplace.Token
import Marketplace.Trading
import Marketplace.Utils


template Operator
  with
    operator : Party
  where
    signatory operator

    key operator : Party
    maintainer key

    controller operator can
      nonconsuming Operator_OnboardCustodian : ContractId CustodianInvitation
        with
          custodian : Party
        do
          create CustodianInvitation with ..

      nonconsuming Operator_OnboardIssuer : ContractId IssuerInvitation
        with
          issuer : Party
          custodian : Party
        do
          exerciseByKey @Custodian (operator, custodian) Custodian_AddIssuer with ..
          create IssuerInvitation with ..

      nonconsuming Operator_OnboardInvestor : ContractId InvestorInvitation
        with
          investor : Party
          custodian : Party
        do
          exerciseByKey @Custodian (operator, custodian) Custodian_AddInvestor with ..
          create InvestorInvitation with ..

      nonconsuming Operator_OnboardExchange : ContractId ExchangeInvitation
        with
          exchange : Party
          custodian : Party
        do
          exerciseByKey @Custodian (operator, custodian) Custodian_AddExchange with ..
          create ExchangeInvitation with ..


template InvestorInvitation
  with
    operator : Party
    investor : Party
  where
    signatory operator

    controller investor can
      InvestorInvitation_Accept : ContractId Investor
        do create Investor with ..


template Investor
  with
   operator : Party
   investor : Party
  where
    signatory operator, investor

    key (operator, investor) : (Party, Party)
    maintainer key._1

    controller investor can
      nonconsuming Investor_TransferTo : ContractId AssetDeposit
        with
          receiver : Party
          depositCid : ContractId AssetDeposit
        do
          deposit <- fetch depositCid
          assertMsg "Can only transfer deposits on main account"
            $ deposit.account.id.label == getAccountLabel investor deposit.account.provider
          (senderRuleCid, senderRule) <- fetchByKey @AssetSettlementRule deposit.account.id
          let receiverAccountId = getAccountId receiver deposit.account.provider [deposit.account.provider]
          (receiverRuleCid, receiverRule) <- fetchByKey @AssetSettlementRule receiverAccountId
          exercise senderRuleCid AssetSettlement_Transfer with ..

      nonconsuming Investor_AllocateToExchange : ContractId AssetDeposit
        with
          exchange : Party
          depositCid : ContractId AssetDeposit
        do
          deposit <- fetch depositCid
          (senderRuleCid, senderRule) <- fetchByKey @AssetSettlementRule deposit.account.id
          let exchangeAccountId = getAccountId investor exchange [deposit.account.provider]
          (exchangeAccountCid, exchangeAccount) <- fetchByKey @AssetSettlementRule exchangeAccountId
          exercise senderRuleCid AssetSettlement_Transfer with receiverAccountId = exchangeAccountId, ..


template ExchangeInvitation
  with
    operator : Party
    exchange : Party
  where
    signatory operator

    controller exchange can
      ExchangeInvitation_Accept : ContractId Exchange
        do create Exchange with tokenPairs = [], participants = [], ..


template Exchange
  with
    operator : Party
    exchange : Party
    tokenPairs : [TokenPair] -- tokens pairs that are tradable on the exchange
    participants : [Party]
  where
    signatory operator, exchange

    key (operator, exchange) : (Party, Party)
    maintainer key._1

    observer participants

    controller exchange can
      Exchange_InviteParticipant : (ContractId Exchange, ContractId ExchangeParticipantInvitation)
        with
          exchParticipant : Party
        do
          participantInvitationCid <- create ExchangeParticipantInvitation with ..
          exchangeCid <- create this with participants = dedup $ exchParticipant :: participants
          return (exchangeCid, participantInvitationCid)

      Exchange_AddPair : ContractId Exchange
        with
          baseTokenId : Id
          quoteTokenId : Id
        do
          (_, baseToken) <- fetchByKey @Token baseTokenId
          (_, quoteToken) <- fetchByKey @Token quoteTokenId
          assertMsg "Pair must have different base and quote tokens" $ baseToken.id.label /= quoteToken.id.label
          create this with tokenPairs = dedup $ (baseTokenId, quoteTokenId) :: tokenPairs


template ExchangeParticipantInvitation
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
  where
    signatory operator, exchange

    controller exchParticipant can
      ExchangeParticipantInvitation_Accept : ContractId ExchangeParticipant
        do create ExchangeParticipant with ..


template ExchangeParticipant
  with
    operator : Party
    exchange : Party
    exchParticipant : Party
  where
    signatory operator, exchange, exchParticipant

    key (exchange, exchParticipant) : (Party, Party)
    maintainer key._1

    controller exchParticipant can
      nonconsuming ExchangeParticipant_PlaceBid : ContractId OrderRequest
        with
          depositCid : ContractId AssetDeposit
          pair : TokenPair
          price : Decimal
        do
          deposit <- fetch depositCid
          (exchangeCid, exchangeCdata) <- fetchByKey @Exchange (operator, exchange)
          assertMsg "deposit is not allocated to the exchange"
            $ deposit.account.id.label == getAccountLabel exchParticipant exchange
          assertMsg ("pair " <> pair._1.label <> "/" <> pair._2.label <> " is not supported by exchange")
            $ pair `elem` exchangeCdata.tokenPairs
          assertMsg ("deposit should be for " <> pair._2.label <> " but it is for " <> deposit.asset.id.label)
            $ pair._2 == deposit.asset.id
          (_, baseToken) <- fetchByKey @Token pair._1
          let qty = roundBankers baseToken.quantityPrecision $ deposit.asset.quantity / price
              order = Order with isBid = True, status = "New", orderId = -1, ..
          create OrderRequest with ..

      nonconsuming ExchangeParticipant_PlaceOffer : ContractId OrderRequest
        with
          depositCid : ContractId AssetDeposit
          pair : TokenPair
          price : Decimal
        do
          deposit <- fetch depositCid
          (exchangeCid, exchangeCdata) <- fetchByKey @Exchange (operator, exchange)
          assertMsg "deposit is not allocated to the exchange"
            $ deposit.account.id.label == getAccountLabel exchParticipant exchange
          assertMsg ("pair " <> pair._1.label <> "/" <> pair._2.label <> " is not supported by exchange")
            $ pair `elem` exchangeCdata.tokenPairs
          assertMsg ("deposit should be for " <> pair._1.label <> " but it is for " <> deposit.asset.id.label)
            $ pair._1 == deposit.asset.id
          (_, baseToken) <- fetchByKey @Token pair._1
          let qty = roundBankers baseToken.quantityPrecision deposit.asset.quantity
              order = Order with isBid = False, status = "New", orderId = -1, ..
          create OrderRequest with ..


template IssuerInvitation
  with
    operator : Party
    issuer : Party
    custodian : Party
  where
    signatory operator
    controller issuer can
      IssuerInvitation_Accept : ContractId Issuer
        do create Issuer with observers = fromList [custodian], ..


template Issuer
  with
    operator : Party
    issuer : Party
    observers : Set Party
    -- ^ the custodian needs to be part of this set. Ideally everyone needs to be an observer of the issuer
  where
    signatory operator, issuer
    observer observers

    key (operator, issuer) : (Party, Party)
    maintainer key._1

    choice Issuer_SetObservers : ContractId Issuer
      with
        ctrl : Party
        newObservers : Set Party
      controller ctrl
      do
        assert $ ctrl `elem` [operator, issuer]
        create this with observers = newObservers

    controller issuer can
      nonconsuming Issuer_IssueToken : ContractId Token
        with
          name : Text
          quantityPrecision : Int
        do
          let tokenId = Id with signatories = fromList [ issuer ], label = name, version = 0
          create Token with id = tokenId, ..


template CustodianInvitation
  with
    operator : Party
    custodian : Party
  where
    signatory operator

    controller custodian can
      CustodianInvitation_Accept : ContractId Custodian
        do create Custodian with investors = [], exchanges = [], issuers = [], ..


template Custodian
  with
    operator : Party
    custodian : Party
    issuers  : [Party]
    investors : [Party]
    exchanges : [Party]
  where
    signatory operator, custodian

    key (operator, custodian) :  (Party, Party)
    maintainer key._1

    controller operator can
      Custodian_AddIssuer : ContractId Custodian
        with
          issuer : Party
        do
          assertMsg ("Issuer " <> show issuer <> " already exists") $ issuer `notElem` issuers
          create this with issuers = issuer :: issuers

      Custodian_AddExchange : ContractId Custodian
        with
          exchange : Party
        do
          assertMsg ("Exchange " <> show exchange <> " already exists") $ exchange `notElem` exchanges
          create this with exchanges = exchange :: exchanges

      Custodian_AddInvestor : ContractId Custodian
        with
          investor : Party
        do
          assertMsg ("Investor " <> show investor <> " already exists") $ investor `notElem` investors
          create this with investors = investor :: investors

    controller custodian can
      nonconsuming GetAccount : Account
        with
          investor : Party
        do
          let accountId = getAccountId investor custodian [custodian]
          return Account with id = accountId, provider = custodian, owner = investor

      nonconsuming CreateDeposit : ContractId AssetDeposit
        with
          tokenId : Id
          depositQuantity : Decimal
          beneficiary : Party
        do
          (tokenCid, token) <- fetchByKey @Token tokenId
          let quantity = roundBankers token.quantityPrecision depositQuantity
              asset = Asset with id = tokenId, ..
              depositObs = fromList [ beneficiary ]
          account <- exercise self GetAccount with investor = beneficiary
          create AssetDeposit with observers = depositObs, account = account, ..

      nonconsuming UpdateAssetSettlementRules : [ContractId AssetSettlementRule]
        do
          custodianAccounts <- mapA (\u -> do
            let accountId = getAccountId u custodian [custodian]
                account = Account with id = accountId, provider = custodian, owner = u
            optAssetRuleCid <- lookupByKey @AssetSettlementRule accountId
            case optAssetRuleCid of
              None -> create AssetSettlementRule with observers = fromList investors,  ctrls = fromList $ L.filter (/= u) investors, ..
              Some ruleCid -> do
                archive ruleCid
                create AssetSettlementRule with observers = fromList investors, ctrls = fromList $ L.filter (/= u) investors, ..) investors
          exchangeAccounts <- mapA (\e -> do
            mapA (\u -> do
              let accountId = getAccountId u e [custodian]
                  account = Account with id = accountId, provider = custodian, owner = u
              optAssetRuleCid <- lookupByKey @AssetSettlementRule accountId
              case optAssetRuleCid of
                None -> create AssetSettlementRule with observers = fromList [u, custodian, e], ctrls = fromList investors, ..
                Some ruleCid -> return ruleCid) investors) exchanges
          return $ custodianAccounts ++ concat exchangeAccounts
