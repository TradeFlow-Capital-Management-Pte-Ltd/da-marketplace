daml 1.2
module Marketplace.Trading where

import Marketplace.Token
import Marketplace.Transfer
import Marketplace.Utils

import DA.Finance.Asset
import DA.Finance.Types

import DA.Math


template OrderRequest
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant
    ensure order.qty > 0.0

    controller order.exchange can
      OrderRequest_Ack : ContractId Order
        with
          orderId : Int
        do create order with orderId = orderId

      OrderRequest_Reject : ()
        do return ()


template OrderCancelRequest
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant

    key (order.exchange, order.orderId) : (Party, Int)
    maintainer key._1

    controller order.exchange can
      OrderCancel_Ack : ()
        do exerciseByKey @Order (order.exchange, order.orderId) Order_Cancel

      OrderCancel_Reject : ()
        do return ()


template Order
  with
    exchange : Party
    exchParticipant : Party
    pair : TokenPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    depositCid : ContractId AssetDeposit
    status : Text
    orderId : Int
  where
    signatory exchange, exchParticipant
    ensure qty > 0.0

    key (exchange, orderId) : (Party, Int)
    maintainer key._1

    controller exchange can
      Order_Fill : (Optional (ContractId DepositTransferRequest), Optional (ContractId Order))
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
        do
          assert $ fillQty > 0.0
          assert $ fillQty <= qty
          assert $ if isBid then fillPrice <= price
                            else fillPrice >= price
          deposit <- fetch depositCid
          let receiverAccountId = Id
                with signatories = deposit.account.id.signatories,
                      label = getAccountLabel counterParty exchange, version = 0
          (_, baseToken) <- fetchByKey @Token pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            let minFillQty = 10.0 ** (- intToDecimal if isBid then quoteToken.quantityPrecision
                                                              else baseToken.quantityPrecision)
            let depositFillQty = min (if isBid
                                      then roundBankers quoteToken.quantityPrecision $ fillQty * fillPrice
                                      else fillQty)
                                     (deposit.asset.quantity - minFillQty)
            if (depositFillQty > 0.0 && depositFillQty < deposit.asset.quantity)
            then do
              [filledCid, restCid] <- exercise depositCid AssetDeposit_Split
                with quantities = [depositFillQty]
              txReqCid <- create DepositTransferRequest
                with investor = exchParticipant,
                      senderAccountId = deposit.account.id,
                      receiverAccountId = receiverAccountId,
                      depositCid = filledCid
              remainingCid <- create this
                with depositCid = restCid, qty = qty - fillQty, status = "PartiallyFilled"
              return $ (Some txReqCid, Some remainingCid)
            else do
              -- the fillQty is not enough to warrant a deposit transfer
              remainingCid <- create this with qty = qty - fillQty, status = "PartiallyFilled"
              return $ (None, Some remainingCid)
          else do
            txReqCid <- create DepositTransferRequest
              with investor = exchParticipant,
                    senderAccountId = deposit.account.id,
                    receiverAccountId = receiverAccountId,
                    ..
            return $ (Some txReqCid, None)

      Order_Cancel : ()
        do return ()

    controller exchParticipant can
      nonconsuming Order_RequestCancel : ContractId OrderCancelRequest
        do create OrderCancelRequest with order = this
